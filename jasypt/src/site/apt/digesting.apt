
Digesting Correctly (and why you should use jasypt)

  Today, most applications (specially web applications) use some message digesting
  technique for encrypting user passwords. This is just one of the uses
  of message digesting but, by fair, it is the most popular.
  
  There are several possibilities for implementing this, some of the most common are:
  
      * Using <<java.security.MessageDigest>> directly.
      
      []
      
      * Using commons-codec's <<org.apache.commons.codec.digest.DigestUtils>>.
      
      []
      
      * Using one of the standard implementations of ACEGI's 
      <<org.acegisecurity.providers.encoding.PasswordEncoder>> interface.
      
      []
      
      * ...using some other digesting utilities or MessageDigest wrappers.
      
  Having so many possibilities, <<why would we want to use jasypt?>> Well, because
  <none of these techniques completely implements what is stated in the
  RSA standard for the creation of digests (in fact, encryption keys) in
  {{{http://www.rsasecurity.com/rsalabs/node.asp?id=2127}PKCS #5: Password-Based Cryptography Standard}}>
  (ACEGI's PasswordEncoders being the most approximate option to an optimal behaviour).
  
  Standards say that, when digesting, you should:
  
      * <<Use a (preferably random) salt>> with a size of at least 8 bytes which
        you should append to your message before digesting, and then again
        after digesting (so that you can later be able to know which the
        salt was).
        
      []
        
      * Apply <<hashing iteration>>, this is, apply the hashing function
        iteratively to its own results a number of times (at least 1000,
        according to the standard).
  
  And this is precisely what jasypt does for you.
  
  
* Digest creation process with jasypt's Standard\[Byte\|String\]Digester

  The steps taken in jasypt's standard digesters for creating digests are:
  
    [[1]]A random salt of the specified size is securely generated (see 
        <<org.jasypt.salt.SaltGeneration>>). If salt size is zero, no salt will be
        used.
        
    [[2]]The salt bytes are appended at the beginning of the message.
    
    [[3]]The hash function is applied to the salt and message altogether, 
        and then to the
        results of the function itself, as many times as specified
        (iterations).
        
    [[4]]The <undigested> salt is appended at the beginning of the hash
        result.
  
  Put schematically in bytes:
  
    *  DIGEST  =  \|<<S>>\|..(ssb)..\|<<S>>\|<<X>>\|<<X>>\|<<X>>\|...\|<<X>>\|
    
          * <<S>>: salt bytes (plain, not digested).
          
          * ssb: salt size in bytes.
          
          * <<X>>: bytes resulting from hashing (see below).

    []
          
    *  |<<X>>|<<X>>|<<X>>|...|<<X>>|  =  <H>(<H>(<H>(..(it)..<H>(<<Z>>|<<Z>>|<<Z>>|...|<<Z>>|))))
    
          * <H>: Hash function (algorithm).
          
          * it: Number of iterations.
          
          * <<Z>>: Input for hashing (see below).
      
    [] 
       
    *  |<<Z>>|<<Z>>|<<Z>>|...|<<Z>>|  =  |<<S>>|..(ssb)..|<<S>>|<<M>>|<<M>>|<<M>>...|<<M>>|
    
          * <<S>>: salt bytes (plain, not digested).
          
          * ssb: salt size in bytes.
          
          * <<M>>: message bytes.
         
  <<Two digests created for the same message will always be different
  (except in the case of random salt coincidence or no usage of salt).>>
  Because of this, the result of the <<<digest>>> method contains 
  both the <undigested> salt and the digest of salt+message, 
  so that another digest operation can be performed with the same salt 
  on a different message to check if both messages match (all of which will 
  be managed automatically by the <<<matches>>> method).

  Also, when using StandardStringDigester, the resulting digest Strings are BASE64
  encoded to avoid charset issues.
  

* Preventing attacks with salt and hashing iteration

  <Ok, all of this is alright, it is more secure to use salt and iterations,
  but... why? What is the real difference?>
  
  Well... if you mind about your users' passwords (which you really 
  should), you MUST use them. This is why:
 
  
** Brute force attacks

  <<Performed on>>: A single user password.
  
  <<Description>>: The attacker tries to get the user's password by exhaustively
  generating all possible passwords, digesting them and testing if they match with the user's password digest.
  {{{http://en.wikipedia.org/wiki/Brute_force_attack} Learn more}}.

  <<Advantages of digesting correctly>>: By iterating the hash function 
  to a number like 1000 (minimum recommended), the overhead of password
  digest creation for the user at sign-up or sign-in time is not significant,
  but the accumulated cost for a brute force attacker generating millions of
  digests will be very considerable. Remember that the best way to protect your
  encrypted data is making the cost of breaking your security too high to
  deserve the effort.

  
** Dictionary attacks

  <<Performed on>>: A single user password or a complete set of user passwords.
  
  <<Description>>: The attacker tries to get the user's password by matching
  its digest against a set of "most possible" password digests, typically generated from
  a list of words in a dictionary. This attack exploits a severe weakness in nowadays applications, as an important
  amount of users set a dictionary word as their password.
  {{{http://en.wikipedia.org/wiki/Dictionary_attack} Learn more}}.
  
  <<Advantages of digesting correctly>>: By adding a random salt, the 
  weakness of the dictionary-based passwords many people use is reduced
  (they no longer are dictionary words),
  and the possibility of the digest appearing on a set of digests previously
  created by the attacker is minimal.

  
** Birthday attacks

  <<Performed on>>: Complete sets of user passwords.

  <<Description>>: This attack exploits the {{{http://en.wikipedia.org/wiki/Birthday_paradox}Birthday paradox}}, which in brief
  states that, having a large set of user password digests, the possibilities of
  generating a password which digest <collides> with at least one of the digests in
  the set is very much higher than what you would intuitively expect. And this
  possibilities increase dramatically as the size of the set (the number of
  users) augments.
  {{{http://en.wikipedia.org/wiki/Birthday_attack} Learn more}}.
  
  <<Advantages of digesting correctly>>: By adding a random salt the 
  possibilities of a birthday attack to succeed are minimum, because the 
  attacker would have to attack each password separately, and not the set of 
  passwords as a whole, to find a collision. This is because he/she would have 
  to find a password that creates the same digest as the attacked one <using 
  the same salt which was used for digesting it>, which is different for each 
  password (this is, it would become a brute force attack).  
  