<?xml version="1.0" encoding="ISO-8859-1"?>
<faqs title="Frequently Asked Questions">


  <part id="general">
    <title>General</title>
    
    <faq id="what-is-jasypt-useful-for">
      <question>What is jasypt useful for? Give me some examples of use, please...</question>
      <answer>
        <p>
          Jasypt is useful for many encryption tasks associated with applications, for example:
        </p>
        <ul>
          <li>Encrypting passwords.</li>
          <li>Encrypting sensitive information.</li>
          <li>Encrypting data communications.</li>
          <li>Creating sums for integrity checking of data.</li>
          <li>...and many more.</li>
        </ul>
      </answer>
    </faq>

    <faq id="i-dont-use-hibernate">
      <question>I don't use Hibernate at all. Can I use jasypt anyway?</question>
      <answer>
        <p>
          Yes, you can. Jasypt provides an <b>optional</b> integration package for
          Hibernate, but <b>it does not need Hibernate for normal operation</b>. It 
          won't add a dependency on Hibernate to your project unless
          you explicitly add the <i>jasypt-hibernate</i> package.
        </p>
      </answer>
    </faq>

    <faq id="i-dont-use-spring">
      <question>I don't use Spring at all. Can I use jasypt anyway?</question>
      <answer>
        <p>
          Yes, you can. Jasypt is designed to be seamlessly integrated into
          a Spring-based application if required, but <b>it does not depend on Spring</b>
          in any way. It won't add a dependency on Spring to your project nor
          will force you to develop in an IoC-friendly manner.
        </p>
      </answer>
    </faq>
    
    <faq id="which-is-the-difference">
      <question>Which is the difference between digests and password-based encryption?</question>
      <answer>
        <p>
          Digests are the results of applying <b>cryptographic hash functions</b>
          such as MD5,
          and are a type of <i>one-way encryption</i>. This means that an original
          input cannot be reconstructed from its digest, once it has been
          generated.
        </p>
        <p>
          Password-based encryption is a type of <i>bidirectional encryption</i>, which
          means that encrypted data can be decypted to reconstruct the original
          input. Encryption is done by generating an <i>encryption key</i>, and passing it
          to an <b>encryption algorithm</b> such as DES. This key, in password-based
          encryption, is derived from a password set by the user 
          (usually by a applying a digest algorithm to it).
        </p>
      </answer>
    </faq>
    
  </part>



  <part id="passwords">
    <title>Encrypting paswords</title>

    <faq id="i-am-already-using-X-for-encrypting-passwords">
      <question>I am already using X for encrypting passwords. Why would I want to use jasypt instead?</question>
      <answer>
        <p>
          Well, first of all, if you are simply using a <tt>Message.digest()</tt> 
          or a <tt>DigestUtils.md5()</tt>
          call to encrypt your passwords and store them in a database, you should know
          that your password system is much weaker than you think, and that
          acquiring access to your application could be even quite easy for any attackers.
          And it even becomes worse as the number of users in your application increases.
        </p>
        <p>
          If you want to learn why this happens and how you could try to avoid it,
          have a look at the <a href="http://www.jasypt.org/encrypting-passwords.html">Encrypting 
          Passwords Guide</a>.
        </p>
        <p>
          ...and, if you are not using such calls but some other APIs or 
          techniques, maybe you should consider reading
          it anyway to know if jasypt can help you do things better.
        </p>
      </answer>
    </faq>
    
    <faq id="i-want-to-encrypt-a-password">
      <question>I want to encrypt passwords and I know NOTHING about encryption. What do I have to do?</question>
      <answer>
        <p>
          Simply use <a href="http://www.jasypt.org/api/jasypt/apidocs/org/jasypt/util/PasswordEncryptor.html">org.jasypt.util.PasswordEncryptor</a>.
          There is nothing more you need to know (if you don't want to :-)).
        </p>
        <p>
          If you want more power (such as deciding which algorithm to use),
          then you can have a look at <a href="http://www.jasypt.org/api/jasypt/apidocs/org/jasypt/digest/StandardStringDigester.html">org.jasypt.digest.StandardStringDigester</a>.
        </p>
        <p>
          And if you want to know more, have a look at
          the <a href="http://www.jasypt.org/encrypting-passwords.html">Encrypting Passwords</a>
          guide to learn about how a password should be encrypted.
        </p>
      </answer>
    </faq>
    
    <faq id="can-i-decrypt-an-encrypted-password">
      <question>Can I decrypt an encrypted password?</question>
      <answer>
        <p>
          If you have encrypted it using a message digesting technique, 
          which is precisely what you should have done (by using 
          <tt>PasswordEncryptor</tt>, <tt>StandardStringDigester</tt>...), <b>you cannot</b>.
        </p>
        <p>
          This is because digests are a <i>one-way</i> technique. Once you have
          created the digest, there is no way to reconstruct the original message
          (or password) back. To check if an input password matches a stored digest, 
          the password is digested itself and then both digests are matched.
        </p>
        <p>
          And why should passwords be encrypted in a way they cannot be decrypted?
          Because this is safest way to ensure that a password is known only
          to the user that created it, and that <i>no one, not even system or database 
          administrators, can know it</i>.
        </p>
      </answer>
    </faq>
    
    
  </part>


  <part id="behaviour">
    <title>Behaviour</title>
    
    <faq id="what-does-jasypt-do-to-create-password-digests">
      <question>What does jasypt do to create message/password digests, exactly? They are so different to the ones I create manually with a MessageDigest object...</question>
      <answer>
        <p>
          Jasypt follows the RSA standards for the creation of digests 
          (in fact, keys), specifically the use of <b>both a random salt and
          an iteration count</b>.
        </p>
        <p>
          The salt is an array of randomly and securely generated bytes which
          is added to the message prior to digest. The iteration count specifies
          how many times the hash function will be applied to the message.
        </p>
        <p>
          This means that the process of digesting your passwords (or any other 
          messages) with jasypt 
          is not as simple (internally speaking) as just using 
          MessageDigest, and because of this results look quite different.
        </p>
        <p>
          For learning more about how password/message digesting works in jasypt, see
          <a href="http://www.jasypt.org/encrypting-passwords.html">Encrypting Passwords</a> or the
          <a href="http://www.jasypt.org/api/jasypt/apidocs/org/jasypt/digest/StandardStringDigester.html">javadoc for StandardStringDigester</a>.
        </p>
        <p>
          For more info about the RSA standard, see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2127">PKCS #5: Password-Based Cryptography Standard</a>.
        </p>
      </answer>
    </faq>
    
    <faq id="if-i-create-two-digests-of-the-same-message">
      <question>If I create two digests of the same message (or I encrypt the same password twice), results differ. Is that normal?</question>
      <answer>
        <p>
          Yes, it is. It is normal and, specially if you are
          encrypting a password, it is good for you. This is due to the use 
          of a <b>random salt</b>.
        </p>
        <p>
          Using this random salt offers you several important security advantages
          as you can read in <a href="http://www.jasypt.org/encrypting-passwords.html">Encrypting Passwords</a>,
          but if it is important for you that two digests of the same message
          be equal, you can set the salt size to 0 bytes. This will force
          jasypt to avoid the use of a salt when digesting.
        </p>
        <p>
          As a random salt is also used for the obtention
          of keys for password-based encryption, two password-based encryption
          results for the same original input will also differ. Nevertheless, 
          this behaviour cannot be avoided in password-based encryption, as
          a salt is required by the PBE Java API itself.
        </p>
      </answer>
    </faq>
    <faq id="I-see-jasypt-uses-salt-and-iteration-count">
      <question>I see jasypt uses salt and iteration count for creating digests. Does it also use them for generating keys for password-based encryption?</question>
      <answer>
        <p>
          Of course. You see the use of salt and iteration count 
          more thoroughly explained in jasypt documentation when referred to
          digests, but this is simply because many people wrongly (and dangerously) forget about 
          using them when
          doing digests of, say, passwords. Thus, it seemed important to remark
          its use when digesting.
        </p>
        <p>
          On the contrary, password-based encryption is usually done the right way, partly
          because the Java API for PBE enforces it to some extent. Anyway,
          jasypt offers you the advantage of transparently dealing with secure random 
          salt generation and checking.
        </p>
        <p>
          For more info about the way password-based encryption should be done
          (and is done by jasypt), see see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2127">PKCS #5: Password-Based Cryptography Standard</a>.
        </p>
      </answer>
    </faq>
    
  </part>  


  <part id="problems">
    <title>Problems</title>

    <faq id="encrypted-fields-not-in-where">
      <question>I do not get correct results when querying a Hibernate-mapped entity with encrypted fields when I set conditions on some of those fields.</question>
      <answer>
        <p>
          This is normal. Security standards establish that two
          different encryption operations on the same data should not return the same
          value (due to the use of a random salt). Because of this, none of the fields that
          are set to be encrypted when persisted can be a part of a WHERE clause in
          your search queries for the entity they belong to.
        </p>
      </answer>
    </faq>
   
    <faq id="no-unlimited-strength">
      <question>I receive an <tt>InvalidKeyException</tt> when trying to use the <tt>StrongTextEncryptor</tt> or the <tt>PBEWithMD5AndTripleDES</tt> algorithm, but other algorithms work alright.</question>
      <answer>
        <p>
          This probably happens because you need download and install the
          <a href="http://java.sun.com/javase/downloads" target="_blank">Java 
          Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy 
          Files</a> in order to be able to use strong-encryption algorithms like TripleDES.
        </p>
      </answer>
    </faq>
    
  </part>


  
</faqs>